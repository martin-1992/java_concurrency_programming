
## 深入 volatile 关键字
　　并发编程有三个重要特性，分别为原子性、有序性和可见性。
    
- 原子性，指在一次的操作或多次操作中，要么所有操作全部都得到执行，要么所有操作都不执行；
- 可见性，当一个线程对共享变量进行修改，那么另外的线程可立即看到修改后的最新值；
- 有序性，指程序代码在执行过程中的先后顺序，由于 Java 在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。JVM 在处理时为提高程序的运行效率，可能会对输入的代码指令做优化，即指令重排序。单线程的指令重排序能提升运行效率，但多线程的指令重排序则会出问题。

### JMM 保证三大特性
　　Java 的内存模型规定了所有变量都是存在于主内存（RAM）当中的，而每个线程都有自己的工作内存或本地内存，线程对变量的所有操作都必须在自己的工作内存中进行的，而不能直接对主内存进行操作，并且每一个线程都不能访问其他线程的工作内存或本地内存。
  
#### JMM 与原子性
　　对基本数据类型的变量读取赋值操作是原子性的，对引用类型的变量读取和赋值操作也是原子性的，举例：
  
- x = 10，赋值操作，为原子性。执行线程首先会将 x = 10 写入工作内存中，然后再写入主内存；
- y = x，赋值操作，非原子性。因包含两个步骤，1）首先执行线程从主内存中读取 x 的值（如果 x 已经存在于执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存中。2）在执行线程的工作内存中修改 y 的值为 x，然后将 y 的值写入主内存中。两步都是原子操作，但组合起来就不是；
- y++，自增操作，非原子性。包含三个步骤，1）执行线程从主内存中读取 y 的值（如果 y 已经存在于执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存中。2）在执行线程工作内存中为 y 执行加 1 操作。3）将 y 的值写入主内存；
- z = z + 1，加一操作，非原子性，操作流程同自增操作一样；

　　总结：
- 多个原子性的操作在一起就不再是原子性操作；
- 简单的读取与赋值操作是原子性，将一个变量赋给另外一个变量的操作不是原子性；
- Java 内存模型（JMM）只保证了基本读取和赋值的原子性操作，其它的均不保证，使用 synchronized 可保证原子性，要保证自增操作的原子性，可使用 java.util.concurrent.atomic.*。

#### JMM 与可见性
　　在多线程中，某个线程会先从主内存中获取变量（首次读取的话，否则直接在工作内存中读取）。当对该变量执行修改操作后，需将修改后的值写入工作内存中，然后再刷新至主内存中。可见性是保证主内存中的值是最新的，三种方式保证可见性：
  
- 使用关键字 volatile 修饰变量，对于共享资源的读操作会直接在主内存中进行（也会缓存到工作内存中，当其他线程对共享资源进行修改，会导致当前线程在工作内存中的共享资源失效，需重新从主内存中获取），对于共享资源的写操作是先修改工作内容，修改完后会立刻将其刷新到主内存中，保证主内存中的值是最新的；
- synchronized 关键字能够保证同一时刻只有一个线程获得锁，然后执行同步方法，确保在锁释放前，将对变量的修改刷新到主内存当中；
- JUC 提供的显示锁 Lock，操作原理同 synchronized 类似。

#### JMM 与有序性
　　保证有序性方法：

- volatile；
- synchronized，使用同步机制，执行时场景为单线程，能保证最终结果的顺序性；
- 显示锁 Lock，同上。

　　Java 的内存模型具备一些天生的有序性规则，不需要任何同步手段就能够保证有序性，这个规则被称为 Happens-before 原则。如果两个操作的执行次序无法从 happens-before 原则推导出来，就无法保证有序性，即可以对其进行重排序处理。happens-before 原则有：
  
- 程序次序规则，
- 锁定规则，同一个锁是锁定状态，需先对其执行释放操作后才能继续进行 lock 操作；
- volatile 变量规则，当一个变量使用 volatile 关键字修饰，有两个线程，一个读，一个写，则写操作发生于读操作之前；
- 传递规则，操作 A 先于操作 B，而操作 B 又先于操作 C，则操作 A 肯定要先于操作 C，传递性；
- 线程启动原则，Thread 对象的 start() 方法先行发生于对该线程的任何动作；
- 线程中断规则，对线程执行 interrupt() 方法要优先于捕获到中断信号，即如果收到中断信号，在此之前势必有 interrupt()；
- 线程的终结规则，线程的任务执行、逻辑单元执行要发生于线程死亡之前；
- 对象的终结规则，一个对象初始化的完成先行发生于 finalize() 之前。

### volatile 关键字解析

- 保证可见性，即每个线程从主内存中看到的都是最新的值；
- 禁止对指令进行重排序操作，直接在 JVM 和处理器中禁止对 volatile 关键字修饰的指令重排序；
- 不保证原子性。

### volatile 使用场景
　　在使用 volatile 关键字时要充分利用它的可见性以及有序性（防止指令重排序）特点。
  
- 开关控制利用可见性特点，开关控制中最常见的就是进行线程的关闭操作，如下保证 started 一修改就刷新到主内存中，让其他线程看到；
```java
public class ThreadCloseale exteneds Thread {
    // volatile 关键字保证了 started 线程的可见性
    private volatile boolean started = true;
    
    @Override
    public void run() {
        while (started) {
            // do work
        }
    }
    
    public void shutdown() {
        this.started = false;
    }
}
```

- 状态标记利用顺序性特点；
- Singleton 设计模式的 double-check 双重检查也是利用顺序性特点。

### volatile 和 synchronized 的区别

- 使用上的区别；
    - volatile 关键字只能用于修饰实例变量或类变量，不能用于修饰方法以及方法参数和局部变量、常量等；
    - synchronized 关键字不能用于对变量的修饰，只能用于修饰方法或语句块；
    - volatile 修饰的变量可以为 null，synchronized 关键字
